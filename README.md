1.) 
```
Объясните разницу этих четырёх promise:

A) foo().then(() => bar());
B) foo().then(() => { bar(); });
C) foo().then(bar());
D) foo().then(bar)
```

В целом, варианты A и B отличаются только использованием фигурных скобок для определения блока, который вызывает функцию `bar()`.
C и D отличаются тем, как вызывается функция `bar()`: вариант C вызывает ее сразу, а вариант D передает ее в качестве обратного вызова.

A, B: если функция `bar()` возвращает промис, то этот код **НЕ БУДЕТ** ждать, пока промис завершится, прежде чем перейти к следующему действию.

C: функция `bar()` будет вызвана сразу, независимо от того, был ли разрешен промис, возвращаемый функцией `foo()`.

D: eсли функция `bar()` возвращает промис, то этот код **БУДЕТ** ждать, пока промис завершится, прежде чем перейти к следующему действию.

2.)
```
Вы разрабатываете виджет для клиентов, представляющий из себя блок комментариев на сайте.

Клиентов у вашей компании достаточно много. Окружения (проекты), в которые интегрируется ваш блок с комментариями, могут быть принципиально разные, но все клиенты хотят иметь возможность как-то визуально менять стили виджета, например поменять фоновый цвет. Виджет работает в live режиме – это значит, что новые комментарии должны отображаться без перезагрузки страницы.

Ответьте на несколько вопросов:
1. Какие подходы к реализации этой задачи вы видите? Какой из них вы бы выбрали?
2. Что необходимо сделать для того, чтобы в будущем, при поддержке проекта, иметь возможность быстро менять визуальную составляющую проекта? Пожалуйста, опишите в виде списка-алгоритма.
3. Каким образом вы предлагаете организовать обновление списка комментариев в live режиме?
4. Почему вы отдали предпочтение данному варианту реализации?
5. Какие в итоге могут быть ограничения у выбранного подхода к реализации?
```

## По стилям.

Я бы использовал CSS-переменные (с наследованием значений) и localStorage:
- пишем функцию чтения из localStorage `localStorageStyleRead()`, если есть записи для переменных, объявляем их значения оттуда. Если нет, объявлем дефолтные.
- пишем функцию записи переменных в localStorage `localStorageStyleWrite()`, вызываемую при изменении интерфейса пользователем.
- при загрузке страницы, а также при изменении интерфейса пользователем, вызываем `localStorageStyleRead()`

localStorage нужен, чтобы не потерять пользовательские настройки при перезагрузке страницы.

Ограничения, это устаревшие браузеры, которые не поддерживают CSS-переменные и localStorage. Ими бы я пренебрёг.

При использовании JS-фреймворков, таких как React или Vue, для создания компонентов, стили легко могут быть изменены с помощью пропсов.
Опять же, ограничения, это устаревшие браузеры.

Вариант, который охватит более старые браузеры, это задавать переменные в JS и хранить их в куках.

При поддержке проекта стили, которые не может менять пользователь, я бы структурировал по компонентам, с наследованием от родителей.
Задал бы переменные, например SASS для цветов, размеров и т п. А потом собирал бы проект, например, вебпаком.

Если мы используем фреймфорки, экосистема для стилей, как правило, там идёт уже из коробки (ну или с минимальными надстройками).

## По загрузке комментариев в live-режиме.

- Можно использовать JS ассинхронный `fetch` (или синхронный `XMLHttpRequest` для устаревших браузеров, BABEL `fetch` не транспилирует) - назовём этот подход AJAX.
  
  AJAX нужно каждый раз вызывать через какой-то интервал.
- Можно использовать WebSockets. 
  WebSockets держит постоянное двустороннее соединение с сервером, из-за этого могут возникнуть проблемы с масштабированием, когда большое количество пользователей пытаются подключиться к серверу.

При использовании обоих подходов браузер может обрывать соединения и/или стопить выполнение JS.

Если это комментарии к статье, я бы использовал AJAX, исходя из своего опыта:
- дешевле в настройке
- стабильней
- live-режим для обновления комментариев не так критичен, как скажем, чат, от постоянного двустороннего соединения можно отказаться. Комментарии можно обновлять раз в минуту.

С другой стороны, если это комментарии, скажем, прямого эфира (как на Youtube), использование WebSockets необходимо для моментальной доставки.

Резюмируя, способ зависит от бизнес задачи:
- Если это просто комментарии к статье на сайте, дешевле использовать AJAX
- Если это чат, или комментарии к прямому эфиру, нужно использовать WebSockets



